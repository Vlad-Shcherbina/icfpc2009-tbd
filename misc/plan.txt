Я тут хочу описать некий общий фреймворк, который позволит реализоваывать всякие идеи без хуйни и мозгоёбства.

(Перебор с помощью их виртуальной машины заведомо неэффективен. Намного лучше было бы написать симулятор физики, который использует, скажем, метод интегрирования Рунге-Кутта четвёртого порядка и обеспечивает хорошую точность при намного большем кванте времени)

Структура решения такова.

Есть класс виртуальная машина, которая умеет
  загрузить образ
  записать в порт
  прочитать порт
  выполнить итерацию
  склонировать своё внутреннее состояние
  (возможно ещё отладочная хрень типа дампов памяти, но не обязательно)
  
Есть класс контроллер, который умеет
  начать сценарий
  получить "состояние системы"
  осуществить изменение скорости
  склонировать своё внутреннее состояние
  записать историю управлений в файл решений

Далее под виртуальной машиной понимается виртуальная машина с контроллером.

"состояние системы" - это простая структура с полями
  scenario
  score
  fuel
  target radius (только для первой задачи)
objects, где objects - список пар координат объектов относительно Земли. Первый в списке - наш спутник, второй - если присутствует - заправщик. Прочее - целевые спутники.

Есть отдельная простенькая программка на основе этого класса, которая
читает бинарный файл с решением и выдаёт score. Она может работать с любой виртуальной машиной, поддерживающей описанный интерфейс, и предназначена для проверки решений и виртуальных машин. Кроме того, она служит документаций по интерфейсу виртуальной машины, демонстрируя самый естественный вариант использования. (done)

Есть специальный класс История/Физика, который инициализируется виртуальной машиной, в которой начата сессия, и исполняет клон этой машины долгое время, не управляя спутником. Это делается чтобы собрать информацию по движению прочих объектов (их траектории предопределены). Также теоретически он может осуществлять необходимый Матан, типа там расчёт эксцентриситета, периодов обращения и что ещё может потребоваться для методов типа хохмана. История хранится как список "состояний системы".

Есть специальный класс симулятор спутника. Он моделирует только движение спутника (остальное ведь можно брать из истории), и поэтому работает быстро. Кроме того, там может быть рунге-кутта. Он принимает начальные координаты и скорость спутника (скорость вычисляет класс История/Матан), умеет делать произвольный шаг симуляции, придавать импульс спутнику и возвращать координаты спутника.

Есть куча классов, подпрограмм и просто хуйней, в которых реализуются хохманы, их комбинации и прочие высказываемые вами идеи.

Им разрешено пользоваться данными из класса История++.

Однако получаемые таким образом решения содержат предположение о непрерывности модели. Поэтому есть ещё модуль Shaker, который принимает на вход последовательность управлений, историю и требования (в какой момент мимо чего мы должны пролетать) и варьирует управления минимальным образом так, чтобы обеспечить пролёт именно в целый кравнт времени, а не в промежутке. Именно в этом модели интенсивно используются клонирования виртуальной машины.

Основная программа выглядит так:
 загрузить вм
 записать историю (плюс насчитать матан)
 
 попробовать разными способами
   инициализировать хитрожопые алгоритмы
   цикл симуляции (симулятором спутника, а не виртуальной машиной)
     применять хитрожопые алгоритмы
   оценить результат (пока неточно)
   
 выбрать лучший способ симуляции
 shake 
 сохранить решение
 
 
 
 -------------------
 Соответственно каждый, кто разрабатывает хитрожопые алгоритмы, имеет свою версию этой основной программы.


Визуализацию можно добавить в основной цикл (он конечно от этого станет чуть менее наглядным, потому что распадётся на коллбэки) по вкусу, в зависимости от того, насколько хитрожопые сущности надо рисовать. Базовая визуализация (функция нарисовать "состояние системы") тривиальна. Также, удобно рисовать "состояния системы", взятые из истории, с шагом в 10 например, чтобы видеть орбиты.
