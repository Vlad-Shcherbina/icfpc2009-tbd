При использовании виртуальной машины рекомендуется ограничиться следующими операциями.

from vminterface import createScenario,getSolution

from compiled_vm import CompiledVMConstructor
from python_vm import PythonVMConstructor 

scenario = 1001
vm = createScenario(CompiledVMConstructor,"shit1.obf",scenario)
# при этом один шаг уже выполнен
assert vm.state.time == 1

vm2 = vm.clone() # это можно делать в любой момент

vm.executeSteps(10,{1:(1,1),8:(-1,-1),15:(5,5)})
# выполнять десять секунд, при этом разгоняться в первую итерацию тормозить в восьмую
# команды не из этого диапазона допустимы и будут игнорироваться
# обнуление скорости явно указывать не надо - во все остальные в порты будет записаны нули!!!

assert vm.state.time == 11

или например так:
controls = {...}
while vm.state.score == 0.0:
	vm.executeSteps(1,controls)
	
или даже так:
controls = {...}
stepsRunned = vm.executeSteps(4000000,controls)
при этом общее количество шагов будет на единицу больше, т.к. начинали с первого
	
with open("sol","wb") as fout:
	fout.write(getSolution(scenario,totalTime,controls))

#ну и конечно всегда доступен state с кучей полей
#но если вам потребуется его сохранить себе, пишите
myState = copy(vm.state)
#потому что машина может модифицировать свой экземпляр



//////////////
Шаги нумеруются с нуля. Просто нулевой шаг - нефизический, и до его выполнения состояние неопределено.
vm.state.time - это номер шага, которому ещё только предстоит выполняться.
Если в контроле указать элемент vm.state.time,
то при следующем вызове executeSteps
вначале произойдёт соответствующая запись в порты потом будут выполняться итерации.